blueprint:
  name: "Raumlüftungsempfehlung (Feuchte + CO₂)"
  description: >
    Empfiehlt Lüften oder Fenster schließen basierend auf relativer/absoluter Luftfeuchtigkeit
    und optional CO₂. Meldungen werden auf ein konfigurierbares Intervall begrenzt (z. B. 1x pro Tag),
    überschreiben sich gegenseitig und berücksichtigen Fensterstatus, Anwesenheit und Zeitfenster.
    Meldungen werden automatisch entfernt, wenn die empfohlene Aktion durchgeführt wurde.
  domain: automation

  input:
    # --- Sensoren ---
    indoor_humidity:
      name: "Relative Luftfeuchtigkeit Innen (%)"
      selector:
        entity:
          domain: sensor
          device_class: humidity

    indoor_absolute:
      name: "Absolute Luftfeuchtigkeit Innen (g/m³)"
      selector:
        entity:
          domain: sensor

    outdoor_absolute:
      name: "Absolute Luftfeuchtigkeit Außen (g/m³)"
      selector:
        entity:
          domain: sensor

    window_sensors:
      name: "Fenster-/Türsensor(en) (optional)"
      description: >
        Optional: Fenster- oder Türkontakte (device_class: window / door).
        Wenn leer, existiert kein Fensterstatus — Clearing für Lüften/Schließen erfolgt dann nicht automatisch.
      default: []
      selector:
        entity:
          domain: binary_sensor
          device_class:
            - window
            - door
          multiple: true

    presence_persons:
      name: "Personen zur Anwesenheit (optional)"
      description: >
        Optional: Liste von `person`-Entities. Wenn leer, wird Anwesenheit ignoriert (angenommen: jemand zuhause).
      default: []
      selector:
        entity:
          domain: person
          multiple: true

    co2_sensor:
      name: "Optionaler CO₂-Sensor"
      description: "Optional: CO₂ Sensor (device_class: carbon_dioxide)."
      default: ""
      selector:
        entity:
          domain: sensor
          device_class: carbon_dioxide

    # --- Schwellenwerte (konfigurierbar / aus Historie abgeleitet) ---
    threshold_relative:
      name: "Rel. LF-Schwelle (%)"
      description: "Relative Luftfeuchte (innen) ab der Lüftung empfohlen wird (Schimmel-Risiko)."
      default: 60
      selector:
        number:
          min: 40
          max: 80
          step: 1

    threshold_difference:
      name: "Absolute LF-Differenz Schwelle (g/m³)"
      description: "Δabs = abs_in - abs_out. Ab welchem Δabs Lüften empfohlen wird (Vorwärtsschwelle)."
      # Letzter gemeinsamer Konsens: 1.5 g/m³ (lüften ab ~1.5)
      default: 1.5
      selector:
        number:
          min: 0
          max: 10
          step: 0.1

    co2_threshold:
      name: "CO₂-Schwelle (ppm)"
      description: "CO₂-Schwelle zur Auslösung einer Lüftungsempfehlung (Wohnräume: 1000–1200 üblich)."
      default: 1200
      selector:
        number:
          min: 400
          max: 2000
          step: 50

    min_vent_duration:
      name: "Mindest-Lüftungsdauer (Minuten)"
      description: >
        Minimale Lüftungsdauer, bevor ggf. eine Schließen-Empfehlung erfolgen kann.
        Bei Kippfenstern eher 15–20 min, bei Stoßlüftung 5–10 min.
      default: 20
      selector:
        number:
          min: 1
          max: 60
          step: 1

    # --- zusätzliche konfigurierbare Close-/Summer-Parameter (nach Wunsch erweitert) ---
    summer_block_threshold:
      name: "Summer-Block Schwelle (g/m³)"
      description: >
        Wenn außen feuchter als innen um diesen Wert (g/m³), wird Lüften blockiert (Sommer-Block).
        Größerer Wert = seltener blocken; kleinerer Wert = früher blocken.
      default: 2
      selector:
        number:
          min: 0
          max: 5
          step: 0.1

    close_diff_threshold:
      name: "Schließen bei Δabs (g/m³)"
      description: "Wenn Δabs (abs_in - abs_out) unter diesen Wert fällt, sollte geschlossen werden."
      default: 0.5
      selector:
        number:
          min: 0
          max: 5
          step: 0.1

    close_rh_threshold:
      name: "Schließen bei relativer LF (%)"
      description: "Wenn die relative Luftfeuchte im Raum unter diesen Wert fällt, kann geschlossen werden."
      default: 50
      selector:
        number:
          min: 30
          max: 60
          step: 1

    # --- Benachrichtigungskontrolle ---
    notify_repeat_hours:
      name: "Benachrichtigungsintervall (h)"
      description: "Wie oft pro Raum maximal eine Meldung erlaubt ist (z. B. 24 = max. 1x pro Tag)."
      default: 24
      selector:
        number:
          min: 1
          max: 24
          step: 1

    notify_targets:
      name: "Benachrichtigung an (Geräte)"
      description: "Mobile App Geräte (multiple)."
      selector:
        device:
          filter:
            - integration: mobile_app
          multiple: true

    # --- Zeitfenster ---
    time_start:
      name: "Start Zeitfenster"
      default: "06:00"
      selector:
        time:

    time_end:
      name: "End Zeitfenster"
      default: "22:00"
      selector:
        time:

    # --- Status-Helper (vom Nutzer anzulegen / zuweisen) ---
    helper_status:
      name: "Helper: Letzter Lüftungsstatus (input_text)"
      description: "Speichert zuletzt gesendeten Status: 'lüften' / 'schließen' / 'warnung' / 'none'."
      selector:
        entity:
          domain: input_text

    helper_last_notify:
      name: "Helper: Letzte Benachrichtigung (input_datetime)"
      description: "Speichert Zeitpunkt der letzten versendeten Benachrichtigung (für notify_repeat_hours)."
      selector:
        entity:
          domain: input_datetime

mode: single

# -----------------------
# Variablen (berechnet)
# -----------------------
variables:
  # Eingabereferenzen
  sensor_humidity: !input indoor_humidity
  sensor_absolute: !input indoor_absolute
  sensor_outdoor: !input outdoor_absolute
  sensor_windows: !input window_sensors
  sensor_persons: !input presence_persons
  sensor_co2: !input co2_sensor
  helper_status: !input helper_status
  helper_last_notify: !input helper_last_notify

  # Konfigurationswerte (als Variablen verfügbar)
  threshold_relative: !input threshold_relative
  threshold_difference: !input threshold_difference
  co2_threshold: !input co2_threshold
  min_vent_duration: !input min_vent_duration
  summer_block_threshold: !input summer_block_threshold
  close_diff_threshold: !input close_diff_threshold
  close_rh_threshold: !input close_rh_threshold
  notify_repeat_hours: !input notify_repeat_hours
  time_start: !input time_start
  time_end: !input time_end
  notify_targets: !input notify_targets

  # Messwerte (gereade aus den Sensoren)
  rh_in: "{{ states(sensor_humidity) | float(0) }}"
  abs_in: "{{ states(sensor_absolute) | float(0) }}"
  abs_out: "{{ states(sensor_outdoor) | float(0) }}"
  area: "{{ area_name(sensor_humidity) }}"
  diff: "{{ (abs_in - abs_out) | round(2) }}"
  co2: "{{ states(sensor_co2) | float(0) if sensor_co2 != '' else 0 }}"
  invalid_sensor: "{{ rh_in <= 1 or abs_in <= 0.5 }}"

  # Fensterstatus / Anwesenheit / Zeit
  no_windows: "{{ (sensor_windows | length) == 0 }}"
  window_open: "{{ sensor_windows | length > 0 and (expand(sensor_windows) | selectattr('state','eq','on') | list | length > 0) }}"
  someone_home: >
    {% if sensor_persons | length > 0 %}
      {{ sensor_persons | map('states') | select('equalto', 'home') | list | length > 0 }}
    {% else %}
      {{ true }}
    {% endif %}
  within_time: >
    {% set now_ts = as_timestamp(now()) %}
    {% set start_ts = as_timestamp(today_at(time_start)) %}
    {% set end_ts = as_timestamp(today_at(time_end)) %}
    {{ start_ts <= now_ts <= end_ts if start_ts <= end_ts else now_ts >= start_ts or now_ts <= end_ts }}

  # Bewertung (Logik)
  high_humidity: "{{ rh_in > threshold_relative and diff > threshold_difference }}"
  bad_co2: "{{ (sensor_co2 != '') and (co2 > co2_threshold) }}"
  # Summer-Block: draußen deutlich feuchter als innen => Lüften blockieren
  summer_block: "{{ abs_out > abs_in + (summer_block_threshold | float) }}"

  # Entscheidungen (verwenden die konfigurierbaren Schwellen)
  should_vent: >
    {{ not invalid_sensor and within_time and someone_home and (no_windows or not window_open)
       and (high_humidity or (bad_co2 and not summer_block)) }}
  should_close: >
    {{ not invalid_sensor and within_time and someone_home and (window_open or no_windows)
       and not bad_co2 and (diff < (close_diff_threshold | float) or rh_in < (close_rh_threshold | float)) }}
  warn_window_open_absent: "{{ within_time and not someone_home and window_open and not no_windows }}"

  # Vent-Dauer (prüfen, ob Mindest-Lüftungsdauer erreicht wurde)
  vent_duration_passed: >
    {% if not no_windows and window_open %}
      {% set oldest = expand(sensor_windows) | selectattr('state','eq','on') | map(attribute='last_changed') | min %}
      {{ (as_timestamp(now()) - as_timestamp(oldest)) / 60 >= min_vent_duration }}
    {% else %}
      {{ true }}
    {% endif %}

  # Meldungsbegrenzung (1x pro notify_repeat_hours)
  last_status: "{{ states(helper_status) }}"
  last_notify: "{{ as_datetime(states(helper_last_notify)) if states(helper_last_notify) not in ['unknown','unavailable','none'] else none }}"
  current_status: >
    {% if should_vent %} lüften
    {% elif should_close %} schließen
    {% elif warn_window_open_absent %} warnung
    {% else %} none
    {% endif %}
  status_changed: "{{ last_status != current_status }}"
  notify_due: >
    {% if last_notify is none %}
      true
    {% else %}
      {{ (as_timestamp(now()) - as_timestamp(last_notify)) / 3600 >= notify_repeat_hours }}
    {% endif %}

# -----------------------
# Trigger: auf relevante Änderungen reagieren
# -----------------------
triggers:
  - trigger: state
    entity_id: !input indoor_humidity
  - trigger: state
    entity_id: !input indoor_absolute
  - trigger: state
    entity_id: !input outdoor_absolute
  - trigger: state
    entity_id: !input window_sensors
  - trigger: state
    entity_id: !input presence_persons
  - trigger: template
    value_template: "{{ sensor_co2 != '' and states(sensor_co2)|float(0) > co2_threshold }}"
  - trigger: time
    at: !input time_start
  - trigger: time
    at: !input time_end

# -----------------------
# Actions
# -----------------------
action:
  - choose:
      # -----------------------
      # Fenster schließen → sofort (wenn vent_duration_passed erfüllt)
      # -----------------------
      - conditions: "{{ (should_close and vent_duration_passed) and (status_changed or notify_due) }}"
        sequence:
          # Push an alle ausgewählten Geräte
          - repeat:
              for_each: "{{ notify_targets }}"
              sequence:
                - service: "notify.mobile_app_{{ device_attr(repeat.item,'name') | slugify }}"
                  data:
                    title: "{{ area }} - Fenster schließen"
                    message: >
                      Fenster schließen empfohlen! Innen: {{ rh_in | round(1) }} % rF,
                      Δabs: {{ diff | round(1) }} g/m³{% if sensor_co2 != '' %}, CO₂: {{ co2 | round(0) }} ppm{% endif %}
                    data:
                      push:
                        interruption-level: time-sensitive
                      tag: lueften_{{ area | slugify }}
          # Persistente Notification (WebUI)
          - service: persistent_notification.create
            data:
              title: "{{ area }} - Fenster schließen"
              message: >
                Fenster schließen empfohlen! Innen: {{ rh_in | round(1) }} % rF,
                Δabs: {{ diff | round(1) }} g/m³{% if sensor_co2 != '' %}, CO₂: {{ co2 | round(0) }} ppm{% endif %}
              notification_id: lueften_{{ area | slugify }}
          # Status-Helper setzen + Zeitstempel für Intervall
          - service: input_text.set_value
            data:
              entity_id: "{{ helper_status }}"
              value: "{{ current_status }}"
          - service: input_datetime.set_datetime
            data:
              entity_id: "{{ helper_last_notify }}"
              datetime: "{{ now().isoformat() }}"

      # -----------------------
      # Lüften / Reminder
      # -----------------------
      - conditions: "{{ should_vent and (status_changed or notify_due) }}"
        sequence:
          - repeat:
              for_each: "{{ notify_targets }}"
              sequence:
                - service: "notify.mobile_app_{{ device_attr(repeat.item,'name') | slugify }}"
                  data:
                    title: "{{ area }} - Lüften"
                    message: >
                      Lüften empfohlen! Innen: {{ rh_in | round(1) }} % rF,
                      Δabs: {{ diff | round(1) }} g/m³{% if sensor_co2 != '' %}, CO₂: {{ co2 | round(0) }} ppm{% endif %}
                    data:
                      push:
                        interruption-level: time-sensitive
                      tag: lueften_{{ area | slugify }}
          - service: persistent_notification.create
            data:
              title: "{{ area }} - Lüften"
              message: >
                Lüften empfohlen! Innen: {{ rh_in | round(1) }} % rF,
                Δabs: {{ diff | round(1) }} g/m³{% if sensor_co2 != '' %}, CO₂: {{ co2 | round(0) }} ppm{% endif %}
              notification_id: lueften_{{ area | slugify }}
          - service: input_text.set_value
            data:
              entity_id: "{{ helper_status }}"
              value: "{{ current_status }}"
          - service: input_datetime.set_datetime
            data:
              entity_id: "{{ helper_last_notify }}"
              datetime: "{{ now().isoformat() }}"

      # -----------------------
      # Warnung: Fenster offen bei Abwesenheit
      # -----------------------
      - conditions: "{{ warn_window_open_absent and (status_changed or notify_due) }}"
        sequence:
          - repeat:
              for_each: "{{ notify_targets }}"
              sequence:
                - service: "notify.mobile_app_{{ device_attr(repeat.item,'name') | slugify }}"
                  data:
                    title: "{{ area }} - Fenster offen"
                    message: "Achtung: Fenster noch offen, während niemand zuhause ist!"
                    data:
                      push:
                        interruption-level: time-sensitive
                      tag: lueften_{{ area | slugify }}
          - service: persistent_notification.create
            data:
              title: "{{ area }} - Fenster offen"
              message: "Achtung: Fenster noch offen, während niemand zuhause ist!"
              notification_id: lueften_{{ area | slugify }}
          - service: input_text.set_value
            data:
              entity_id: "{{ helper_status }}"
              value: "{{ current_status }}"
          - service: input_datetime.set_datetime
            data:
              entity_id: "{{ helper_last_notify }}"
              datetime: "{{ now().isoformat() }}"

  # -----------------------
  # Clear-Meldungen bei erfolgreicher Aktion (nur wenn Bedingung erfüllt)
  # - LÜFTEN: clear, wenn Fenster geöffnet wurde (nur bei vorhandenen Fenstersensoren)
  # - SCHLIESSEN: clear, wenn Fenster geschlossen wurde (nur bei vorhandenen Fenstersensoren)
  # - WARNUNG: clear, wenn Fenster geschlossen wurde (wenn Sensor vorhanden) oder jemand nach Hause kommt
  # -----------------------
  - choose:
      - conditions: >
          {{ (last_status == 'lüften' and not no_windows and window_open)
             or (last_status == 'schließen' and not no_windows and not window_open)
             or (last_status == 'warnung' and ((not no_windows and not window_open) or someone_home)) }}
        sequence:
          # Push-Clearing (Companion App iOS/Android): sendet "clear_notification" mit gleichem Tag
          - repeat:
              for_each: "{{ notify_targets }}"
              sequence:
                - service: "notify.mobile_app_{{ device_attr(repeat.item,'name') | slugify }}"
                  data:
                    message: "clear_notification"
                    data:
                      tag: lueften_{{ area | slugify }}
          # WebUI persistent notification löschen
          - service: persistent_notification.dismiss
            data:
              notification_id: lueften_{{ area | slugify }}
          # Helper-Status auf none zurücksetzen
          - service: input_text.set_value
            data:
              entity_id: "{{ helper_status }}"
              value: "none"
